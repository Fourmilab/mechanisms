
    /*  All code starting with this line is generic: it is
        used for all segments of all animations.  Note that
        this file is NOT a complete LSL script: it contains
        the common code which is appended to the specific
        declarations for an animation segment generated by
        compile_animation.pl in this directory.  */

    key client;                     // UUID of client requesting animation

    integer currentFrame = -1;      // Current frame being played

    //  Link messages

    //  Animation Player messages

    integer LM_AP_PLAY = 241;       // Play entire animation
    integer LM_AP_COMPLETE = 242;   // Animation play complete
    integer LM_AP_STOP = 243;       // Stop current animation

    //  expRot  --  Expand compressed rotation into something like the original

    rotation expRot(integer cr) {
        vector icomps = < (float) (cr >> 20),
                          (float) ((cr >> 10) & 1023),
                          (float) (cr & 1023) >;
        icomps -= <512, 512, 512>;      // Re-centre around zero
        icomps *= PI / 511;             // Re-scale to radians
        return llEuler2Rot(icomps);
    }

    //  expPos  --  Expand a 48-bit compressed position into a vector

    vector expPos(integer ix, integer iyz) {
        return < ((ix << 16) >> 16),      // Dirty trick to sign-extend
                 (iyz >> 16),             // Note >> sign-extends
                 ((iyz << 16) >> 16) > / 10000.0;
    }

    /*  expandFrame  --  Expand a compressed frame into a ready-to-use
                         rule list for llSetLinkPrimitiveParamsFast()
                         and apply it.  */

    expandFrame(list olist) {
        integer i = 0;
        integer n = llGetListLength(olist);
        list exlist = [ ];

        while (i < n) {
            integer rule = llList2Integer(olist, i);
            integer mrule = rule & 0xFF;

            if (mrule == 91) {
                //  (91 | (link << 8)), pos, rot
                exlist += [ PRIM_LINK_TARGET, rule >> 8,
                            PRIM_POS_LOCAL, llList2Vector(olist, i + 1),
                            PRIM_ROT_LOCAL,
                                expRot(llList2Integer(olist, i + 2))
                          ];
                i += 3;

            } else if (mrule == 92) {
                //  (92 | (link << 8)), pos
                exlist += [ PRIM_LINK_TARGET, rule >> 8,
                            PRIM_POS_LOCAL, llList2Vector(olist, i + 1) ];
                i += 2;

            } else if (mrule == 93) {
                //  (93 | (link << 8)), rot
                exlist += [ PRIM_LINK_TARGET, rule >> 8,
                            PRIM_ROT_LOCAL,
                                expRot(llList2Integer(olist, i + 1))
                          ];
                i += 2;

            } else if (mrule == 94) {
                //  (94 | (link << 8) | (compX << 16)), (compY << 16) | (compZ << 16), rot
                exlist += [ PRIM_LINK_TARGET, (rule >> 8) & 0xFF,
                            PRIM_POS_LOCAL,
                                expPos(rule >> 16, llList2Integer(olist, i + 1)),
                            PRIM_ROT_LOCAL,
                                expRot(llList2Integer(olist, i + 2))
                          ];
                i += 3;

            } else if (mrule == 95) {
                //  (95 | (link << 8) | (compX << 16)), (compY << 16) | (compZ << 16)
                exlist += [ PRIM_LINK_TARGET, (rule >> 8) & 0xFF,
                            PRIM_POS_LOCAL,
                                expPos(rule >> 16, llList2Integer(olist, i + 1)) ];
                i += 2;
            } else {
                //  Uncompressed rule, value pair ???
                exlist += llList2List(olist, i, i + 1);
                i += 2;
            }
        }
        llSetLinkPrimitiveParamsFast(LINK_ROOT, exlist);
    }

    //  nextFrame  --  Play next frame of complete animation

    nextFrame() {
        playFrame(currentFrame);
        currentFrame++;
        if (currentFrame <= frameEnd) {
            //  Next frame is within the segment; start timer to play it
            llSetTimerEvent(frameTime);
        } else {
            llSetTimerEvent(0);     // We're done in this script.  Cancel timer
            if (currentFrame <= frameLast) {
                //  Next frame is in another segment: start it
                llMessageLinked(LINK_THIS, LM_AP_PLAY | (currentFrame << 8),
                    animation, client);
                currentFrame = -1;  // Mark this script no longer active
            } else {
                /*  We have just played the last frame of the
                    entire animation.  Notify client we're done.  */
                llMessageLinked(LINK_THIS, LM_AP_COMPLETE, animation, client);
                currentFrame = -1;  // Mark this script no longer active
            }
        }
    }

    default {

        state_entry() {
/* IF MEMORY_USAGE
            /*  Enable this code when tuning how many frames fit in
                each segment script. *_/
            integer mFree = llGetFreeMemory();
            integer mUsed = llGetUsedMemory();
            llOwnerSay("  " + llGetScriptName() + " script memory.  Free: " + (string) mFree +
                    "  Used: " + (string) mUsed + " (" +
                    (string) ((integer) llRound((mUsed * 100.0) / (mUsed + mFree))) + "%)"
            );
/* END MEMORY_USAGE */
        }

        link_message(integer sender, integer num, string str, key id) {
            integer request = num & 0xFF;           // Request code (frame encoded in high bits)

            //  LM_AP_PLAY (241): Play animation

            if (request == LM_AP_PLAY) {
                if (str == animation) {
                    currentFrame = num >> 8;    // Starting frame
                    if (currentFrame == frameStart) {
                        //  Starting frame is in this segment.  Start playing
                        client = id;
                        nextFrame();
                    } else {
                        currentFrame = -1;      // Mark no frame being played
                    }
                }

            //  LM_AP_STOP (243): Stop current animation

            } else if (request == LM_AP_STOP) {
                if (currentFrame >= 0) {
                    llSetTimerEvent(0);
                    currentFrame = -1;
                    llMessageLinked(LINK_THIS, LM_AP_COMPLETE, animation, client);
                }
            }
        }

        //  The timer is used to play successive frames of the animation

        timer() {
            nextFrame();
        }
    }
